# A0127481E
###### java\gui\TasksItemController.java
``` java
	
	private boolean isToday(List<Date> dates) {
		int size = dates.size();
		if (size == 0) {
			return false;
		}
		else {
			Date today = new Date();
			String todayDate = today.toString().substring(0, 9);
			if (size == 1) {
				if (dates.get(0).toString().substring(0,9).equals(todayDate)) {
					return true;
				}
			}
			else if (size == 2) {
				if (today.after(dates.get(0)) && today.before(dates.get(1))) {
					return true;
				}
			}
		}
		
		return false;
	}


	private String showTime(List<Date> dates) {
		SimpleDateFormat df = new SimpleDateFormat("EEEE dd MMM hh:mma");
		SimpleDateFormat df1 = new SimpleDateFormat("hh:mma");
		SimpleDateFormat df2 = new SimpleDateFormat("EEEE dd MMM");
		SimpleDateFormat df3 = new SimpleDateFormat("EEEE");
		if (dates.size() == 0) {
			return "No specified time";
		}
		else {
			if (taskType == TASK_NATURE.DEADLINE) {
				return "Due: " + df.format(dates.get(0));
			}
			else if (taskType == TASK_NATURE.DURATION) {
				String time;
				//System.out.println(dates);
				if (dates.get(0).toString().substring(0, 10).equals(dates.get(1).toString().substring(0, 10))) {
					time = df2.format(dates.get(0)) + " " + df1.format(dates.get(0)) 
					+ " - " + df1.format(dates.get(1));
				}
				else {
					time = "" + df.format(dates.get(0)) 
					+ " to " + df.format(dates.get(1));
				}
				return time;
			}
			else {
				String time = "";
				for (int i = 0; i < dates.size(); i++) {
					time += df.format(dates.get(i));
					if (i + 1 < dates.size()) {
						time += ", ";
					}
				}
				return time;
			}
//			else if (taskType == TASK_NATURE.RECURRING_EVERY){
//				String time = "Every " + df3.format(dates.get(0));
//				return time;
//			}
//			else {
//				String time = "Every alternate " + df3.format(dates.get(0));
//				return time;
//			}
		}
	}
```
###### java\logic\CommandDispatcher.java
``` java
package main.java.logic;


import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.data.*;
import main.java.parser.*;

public class CommandDispatcher {

	private static final String EMPTY_STRING = "";
	private static final String WHITE_SPACE = " ";

	public CommandDispatcher() {

	}
	public Command parseCommand(Command command)throws InvalidInputFormatException {
		assert command != null;
		String originalCommand = command.getOriginal();

		if (originalCommand.isEmpty()) {
			throw new InvalidInputFormatException("Empty command is not allowed!");
		}

		command.setType(determineCommandType(originalCommand));
		String commandContent = retrieveCommandContent(command);
		command.setContent(commandContent);
		setParameters(command);
		return command;
	}

	private void setParameters(Command command)throws InvalidInputFormatException {

		if (command.isCommand(COMMAND_TYPE.ADD)) {
			AddCommandParser parser = new AddCommandParser();
			//System.out.println(command.getContent());
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.EDIT)) {
			EditCommandParser parser = new EditCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.DELETE)) {
			DeleteCommandParser parser = new DeleteCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.DELETE_COMPLETE)) {
			DeleteCommandParser parser = new DeleteCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.MOVE)) {
			StorageCommandParser parser = new StorageCommandParser();
			command.setParameters(parser.determineParameters
					(command.getType(),command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.SAVE)) {
			StorageCommandParser parser = new StorageCommandParser();
			command.setParameters(parser.determineParameters
					(command.getType(),command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.SORT)
				|| command.isCommand(COMMAND_TYPE.SORT_COMPLETE)) {
			SortCommandParser parser = new SortCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
		else if (command.isCommand(COMMAND_TYPE.SHOW) 
				|| command.isCommand(COMMAND_TYPE.SHOW_COMPLETE)) {
			ShowCommandParser parser = new ShowCommandParser();
			command.setParameters(parser.determineParameters
					(command.getContent()));
		}
	
		else if (command.isCommand(COMMAND_TYPE.INVALID)){
			throw new InvalidInputFormatException("Please enter a valid command!");
		}
		else {
			return;
		}

	}

	private COMMAND_TYPE determineCommandType(String originalCommand) {
		assert originalCommand != null;
		COMMAND_TYPE type = getCommandKeyword(originalCommand);
		return type;
	}

	private COMMAND_TYPE getCommandKeyword(String command) {
		assert command != null;
		String firstWord = getFirstKeyword(command);

		if (isCommand(COMMAND_TYPE.ADD, firstWord)) {
			return COMMAND_TYPE.ADD;
		}

		else if (isCommand(COMMAND_TYPE.DELETE, firstWord)) {
			return COMMAND_TYPE.DELETE;
		}
		else if (isCommand(COMMAND_TYPE.DELETE_COMPLETE, firstWord)) {
			return COMMAND_TYPE.DELETE_COMPLETE;
		}

		else if (isCommand(COMMAND_TYPE.SEARCH, firstWord)) {
			return COMMAND_TYPE.SEARCH;
		}

		else if (isCommand(COMMAND_TYPE.MOVE, firstWord)) {
			return COMMAND_TYPE.MOVE;
		}
		else if (isCommand(COMMAND_TYPE.SAVE, firstWord)) {
			return COMMAND_TYPE.SAVE;
		}

		else if (isCommand(COMMAND_TYPE.SORT, firstWord)) {
			return COMMAND_TYPE.SORT;
		}
		else if (isCommand(COMMAND_TYPE.SORT_COMPLETE, firstWord)) {
			return COMMAND_TYPE.SORT_COMPLETE;
		}

		else if (isCommand(COMMAND_TYPE.CLEAR_UPCOMING, firstWord)) {
			return COMMAND_TYPE.CLEAR_UPCOMING;

		}
		else if (isCommand(COMMAND_TYPE.CLEAR_ALL, firstWord)) {
			return COMMAND_TYPE.CLEAR_ALL;

		}
		else if (isCommand(COMMAND_TYPE.CLEAR_FLOATING, firstWord)) {
			return COMMAND_TYPE.CLEAR_FLOATING;

		}
		else if (isCommand(COMMAND_TYPE.CLEAR_OVERDUE, firstWord)) {
			return COMMAND_TYPE.CLEAR_OVERDUE;

		}
		else if (isCommand(COMMAND_TYPE.CLEAR_COMPLETE, firstWord)) {
			return COMMAND_TYPE.CLEAR_COMPLETE;
		}

		else if (isCommand(COMMAND_TYPE.EDIT, firstWord)) {
			return COMMAND_TYPE.EDIT;

		}

		else if (isCommand(COMMAND_TYPE.UNDO, firstWord)) {
			return COMMAND_TYPE.UNDO;
		}
		else if (isCommand(COMMAND_TYPE.REDO, firstWord)) {
			return COMMAND_TYPE.REDO;
		}
		else if (isCommand(COMMAND_TYPE.MARK, firstWord)) {
			return COMMAND_TYPE.MARK;
		}
		else if (isCommand(COMMAND_TYPE.UNMARK, firstWord)) {
			return COMMAND_TYPE.UNMARK;
		}
		else if (isCommand(COMMAND_TYPE.SWITCH, firstWord)) {
			return COMMAND_TYPE.SWITCH;
		}
		else if (isCommand(COMMAND_TYPE.SHOW, firstWord)) {
			return COMMAND_TYPE.SHOW;
		}
		else if (isCommand(COMMAND_TYPE.SHOW_COMPLETE, firstWord)) {
			return COMMAND_TYPE.SHOW_COMPLETE;
		}
		else {
			return COMMAND_TYPE.INVALID;
		}
	}

	private String getFirstKeyword(String command) {
		assert command != null;
		if (!command.contains(WHITE_SPACE)) {
			return command;
		}
		return command.substring(0,command.indexOf(WHITE_SPACE)).trim();
	}

	private boolean isCommand(COMMAND_TYPE type, String keyword) {
		assert keyword != null;
		return type.getType().equalsIgnoreCase(keyword);
	}

	private String retrieveCommandContent(Command command) {
		assert command != null;
		String original = command.getOriginal();

		//content is empty
		if (!original.contains(WHITE_SPACE)) {
			return EMPTY_STRING;
		}
		//command is not empty
		else {
			String content = original.substring(original.indexOf(WHITE_SPACE) + 1);
			return content.trim();
		}
	}



	public static void main(String[] args)
	{
		PrettyTimeParser parser = new PrettyTimeParser();

		String keyword = "ClEaR";
		String newWord = keyword.toLowerCase();
		if (newWord.equals("clear")) {
			//System.out.println(keyword);
		}
		Object date = PRIORITY_LEVEL.HIGH;
		
		System.out.println(date.getClass());
		//System.out.println(Integer.parseInt("5.5"));
		List<Date> date3 = parser.parse("fri 10pm");
		//SimpleDateFormat df = new SimpleDateFormat("E, d MMM hh:mma");
		//System.out.println(date3);
		//System.out.println(parser.parse("add task by 4 june 2017"));
		String time = "Sat Jun 10 08:00:00 SGT 2017";
		time = time.substring(0, 9) + WHITE_SPACE + 
				time.substring(24, 28) + time.substring(10, 23);
		System.out.println("output time: " + time);
	}
}
```
###### java\logic\CommandDispatcher.java
``` java

```
###### java\logic\Logic.java
``` java
package main.java.logic;


import java.util.ArrayList;
import java.util.Date;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.data.*;
import main.java.parser.*;
import main.java.storage.*;

public class Logic {

	private static final String ADD_COMMAND = "add";
	private static final String DELETE_COMMAND = "delete";
	private static final String SEARCH_COMMAND = "search";
	private static final String CHANGE_DIRECTORY_COMMAND = "move";
	private static final String SORT_COMMAND = "sort";
	private static final String EDIT_COMMAND = "edit";
	private static final String UNDO_COMMAND = "undo";
	private static final String HELP_COMMAND = "help";
	private static final String MARK_COMMAND = "mark";
	private static final String UNMARK_COMMAND = "unmark";
	private static final String CLEAR_COMMAND = "clear";
	private static final String SWITCH_COMMAND = "switch";
	private static final String REDO_COMMAND = "redo";
	private static final String THEME_COMMAND = "theme";
	private static final String SHOW_COMMAND = "show";
	private static final String EMPTY_STRING = "";


	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;


	private static Task task;
	private static TransientTask transientTask;
	private static StorageController storageController;
	private ArrayList<Task> searchResult;
	private ArrayList<Task> searchResultCompleted;
	private static PrettyTimeParser timeParser = new PrettyTimeParser();

	public Logic() {
		try {
			storageController = new StorageController();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}


	public ArrayList<Task> initLogic() throws Exception{
		Logic logic = new Logic();
		searchResult = new ArrayList<Task>();
		searchResultCompleted = new ArrayList<Task>();
		return displayPending();

	}

	public ArrayList<Task> handleUserCommand(String userInput,ArrayList<Task> taskOptions) throws Exception {
		assert userInput != null;

		CommandDispatcher dispatcher = new CommandDispatcher();
		Command command = new Command(userInput);
		command = parseCommand(dispatcher, command);
		
		//		System.out.println("task" + command.getParameters()[TASK]);
		//System.out.println("time" + command.getParameters()[1]);
		//		System.out.println("priority" + command.getParameters()[2]);
		//		System.out.println("type" + command.getParameters()[3]);
		//System.out.println(retrieveTaskIndex(command));


		ArrayList<Task> result = executeTask(command, taskOptions, userInput);

		return result;

	}

	private void handleAddCommand(Task task) throws Exception {
		assert task != null;
		storageController.addTask(task);
	}

	//	private ArrayList<Task> handleDeleteCommand(Task task) {
	//		assert task != null;
	//		return temp.searchTemp(task);
	//	}

	private ArrayList<Task> handleEditCommand(TransientTask task) throws Exception {

		return EditCommandParser.parseEditTask(task);
	}



	private Task createTask(Command command) {
		assert command != null;
		return command.createTask();
	}

	private Command parseCommand(CommandDispatcher dispatcher, Command command)throws InvalidInputFormatException {
		assert command != null;
		return dispatcher.parseCommand(command);
	}

	private ArrayList<Task> executeTask(Command command, ArrayList<Task> taskOptions,String userInput) throws NumberFormatException, Exception {

		ArrayList<Task> result = new ArrayList<Task>();

		if (command.isCommand(COMMAND_TYPE.ADD)) {

			task = createTask(command);
			//System.out.println(task.getTime());
			if (!task.getTask().equals(EMPTY_STRING)) {
				handleAddCommand(task);
			}
			result = storageController.displayPendingTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.CLEAR_ALL)){
			storageController.clearPendingTasks();
			result = storageController.displayPendingTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.CLEAR_FLOATING)){
			storageController.clearFloatingTasks();
			result = storageController.displayPendingTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.CLEAR_UPCOMING)){
			storageController.clearUpcomingTasks();
			result = storageController.displayPendingTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.CLEAR_OVERDUE)){
			System.out.println("clear pending");
			storageController.clearOverdueTasks();
			result = storageController.displayPendingTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.CLEAR_COMPLETE)){
			System.out.println("clear complete");
			storageController.clearCompletedTasks();
			result = storageController.displayCompletedTasks();
		}

		else if (command.isCommand(COMMAND_TYPE.DELETE)) {

			for (Task temp : searchResult) {
				if (userInput.equalsIgnoreCase("delete " + temp.getTask()) 
						|| searchResult.size()==1) {
					delete(temp);			
					break;
				}			
			}
		}

		else if (command.isCommand(COMMAND_TYPE.DELETE_COMPLETE)) {
			for (Task temp : searchResultCompleted) {
				if (userInput.equalsIgnoreCase("deleteComplete " + temp.getTask())
						|| searchResultCompleted.size()==1) {
					deleteComplete(temp);			
					break;
				}			
			}
		}


		else if (command.isCommand(COMMAND_TYPE.EDIT)) {

			ArrayList<Task> finalResult = new ArrayList<Task>(); 
			transientTask = createTransientTask(command);
			result = handleEditCommand(transientTask);
			String sub = userInput.substring(5, userInput.indexOf(","));

			for (Task temp : searchResult) {
				System.out.println("here"+temp.getTask());
				if (temp.getTask().contains(sub)) {				
					finalResult.add(temp);	  
					finalResult.add(result.get(1));

					Task original = finalResult.get(0);

					Task updated = finalResult.get(1);


					if(updated.getTime().toString().equals("[]")){
						updated.setTime(original.getTime());
						updated.setType(original.getType());
						updated.setStatus(original.getStatus());
					}
					if(updated.getPriority()== PRIORITY_LEVEL.NOT_SPECIFIED){
						updated.setPriority(original.getPriority());
					}

					edit(finalResult);

					break;
				}

			}
		}

		else if (command.isCommand(COMMAND_TYPE.MOVE)) {
			moveToLocation(command.getParameters()[TASK]);
		}
		else if (command.isCommand(COMMAND_TYPE.SAVE)) {
			saveToLocation(command.getParameters()[TASK]);
		}
		else if (command.isCommand(COMMAND_TYPE.MARK)) {

			for (Task temp : searchResult) {
				if (userInput.equalsIgnoreCase("mark " + temp.getTask()) || searchResult.size()==1) {
					mark(temp);			
					break;
				}			
			}

		}
		else if (command.isCommand(COMMAND_TYPE.UNMARK)) {

			for (Task temp : searchResultCompleted) {
				if (userInput.equalsIgnoreCase("unmark " + temp.getTask()) || searchResultCompleted.size()==1) {
					unmark(temp);			
					break;
				}			
			}
		}
		
		else if (command.isCommand(COMMAND_TYPE.SHOW) ||
				command.isCommand(COMMAND_TYPE.SHOW_COMPLETE)) {
			
			boolean isTime = false;
			Date timeFilter = null;
			PRIORITY_LEVEL priorityFilter = null;
			if (command.getParameters()[TIME] != null) {
				isTime = true;
				timeFilter = timeParser.parse(command.getParameters()
						[TIME]).get(0);

			}
			
			else {
				String priority = command.getParameters()[PRIORITY];
				
				if (priority.equals(PRIORITY_LEVEL.HIGH.getType())) {
					priorityFilter = PRIORITY_LEVEL.HIGH;
				}
				else if (priority.equals(PRIORITY_LEVEL.MEDIUM.getType())) {
					priorityFilter = PRIORITY_LEVEL.MEDIUM;
				}
				else {
					priorityFilter = PRIORITY_LEVEL.LOW;
				}

			}

			if (command.isCommand(COMMAND_TYPE.SHOW)) {
				
				if (isTime) {
					result = storageController.showAllPendingByDate(timeFilter);
				}
				//filter by priority
				else {
					result = storageController.showAllPendingByPriority(priorityFilter);
				}
				
			}
			//showComplete
			else {
				
				if (isTime) {
					result = storageController.showAllCompletedByDate(timeFilter);
				}
				
				else {
					result = storageController.showAllCompletedByPriority(priorityFilter);
				}	
			}
		}

		else if (command.isCommand(COMMAND_TYPE.SORT) 
				|| command.isCommand(COMMAND_TYPE.SORT_COMPLETE)) {
			String parameter = command.getParameters()[TASK].toLowerCase();
			if (command.isCommand(COMMAND_TYPE.SORT)) {
				if (parameter.equals("time")) {
					storageController.sortPendingByTime();
				}

				else if (parameter.equals("name")) {
					storageController.sortPendingByTaskName();
				}

				else if (parameter.equals("priority")) {
					storageController.sortPendingByPriority();
				}
			}
			else if (command.isCommand(COMMAND_TYPE.SORT_COMPLETE)) {
				if (parameter.equals("time")) {
					storageController.sortCompletedByTime();
				}

				else if (parameter.equals("name")) {
					storageController.sortCompletedByTaskName();
				}

				else if (parameter.equals("priority")) {
					storageController.sortCompletedByPriority();
				} 
			}
		}

		else if (command.isCommand(COMMAND_TYPE.UNDO)) {
			storageController.undo();
		}

		else if (command.isCommand(COMMAND_TYPE.REDO)) {
			storageController.redo();
			//System.out.println("UNDO IS HERE !!!!");
		}

		return result;
	}

	private TransientTask createTransientTask(Command command) {
		return command.createTransientTask();
	}

	public void deleteComplete(Task task) throws Exception {
		storageController.deleteCompletedTask(task);
	}

	public void delete(Task task) throws Exception {
		storageController.deletePendingTask(task);
	}
	
	public void mark(Task task) throws Exception {
		storageController.moveTaskToComplete(task);	
	}

	public void unmark(Task task) throws Exception {
		storageController.moveTaskToPending(task);
	}
	

	public ArrayList<Task> displayPending()throws Exception{
		ArrayList<Task> result = storageController.displayPendingTasks();
		return result;
	}

	public ArrayList<Task> displayComplete()throws Exception{
		ArrayList<Task> result = storageController.displayCompletedTasks();
		return result;
	}

	public void edit(ArrayList<Task> result)throws Exception{

		storageController.editPendingTask(result.get(0), result.get(1));
	}

	public void moveToLocation(String path){	
		
		storageController.moveToLocation(path);
	}

	public void loadFilename(String filename){	
		
		storageController.loadFromFile(filename);
	}

	public void saveToLocation(String path) {
		storageController.saveToLocation(path);
	}

	public boolean isCommand(String commandWord) {
		commandWord = commandWord.toLowerCase();
		if(commandWord.equals(ADD_COMMAND)||commandWord.equals(DELETE_COMMAND)||
				commandWord.equals(EDIT_COMMAND)||commandWord.equals(SEARCH_COMMAND)||
				commandWord.equals(SORT_COMMAND)||commandWord.equals(CHANGE_DIRECTORY_COMMAND)||
				commandWord.equals(CLEAR_COMMAND)||commandWord.equals(UNDO_COMMAND)||commandWord.equals(HELP_COMMAND)||
				commandWord.equals(MARK_COMMAND)||commandWord.equals(REDO_COMMAND) || commandWord.equals(SWITCH_COMMAND)|| 
				commandWord.equals(UNMARK_COMMAND)||commandWord.equals(THEME_COMMAND) || commandWord.equals(SHOW_COMMAND))
			return true;
		return false;

	}


	public ArrayList<Task> handleSearchPending(String oldValue, String newValue) throws Exception {
		//System.out.println("new val: " + newValue);
		//System.out.println("old val: " + oldValue);
		searchResult = storageController.searchMatchPending(newValue);	
		return searchResult;
	}


	public ArrayList<Task> handleSearchCompleted(String oldValue, String newValue) throws Exception {
		//System.out.println("new val: " + newValue);
		//System.out.println("old val: " + oldValue);
		searchResultCompleted = storageController.searchMatchCompleted(newValue);	
		return searchResultCompleted;
	}


	public ArrayList<Task> checkOverdue() {

		return storageController.checkOverdue(new Date());
	}

	public int retrieveTaskIndex(Command command) {
		COMMAND_TYPE type = command.getType();
		String content = command.getContent();
		if (type == COMMAND_TYPE.DELETE) {
			try {
				return Integer.parseInt(content);
			} catch (NumberFormatException e) {
				return -1;
			}
		}
		else if (type == COMMAND_TYPE.EDIT) {
			content = content.substring(0, content.indexOf(","));
			try {
				return Integer.parseInt(content);
			} catch (NumberFormatException e) {
				return -1;
			}
		}
		else {
			return -1;
		}
	}
	public static void main(String[] args) {
		Command command = new Command("delete good");
		command.setContent("good");
		Logic l = new Logic();
		System.out.println(l.retrieveTaskIndex(command));
	}
}
```
###### java\logic\Logic.java
``` java

```
###### java\logic\TestCommandDispatcher.java
``` java
package main.java.logic;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import main.java.data.COMMAND_TYPE;
import main.java.data.Command;
import main.java.parser.AddCommandParser;
import main.java.parser.InvalidInputFormatException;

public class TestCommandDispatcher {
	private static CommandDispatcher dispatcher;
	private static AddCommandParser addParser;

	@Before
	public void setUp() throws Exception {
		dispatcher = new CommandDispatcher();
		addParser = new AddCommandParser();
	}

	@Test
	//cover a case without the command keyword
	public void test() throws InvalidInputFormatException {
		
		String userInput = "on mon 5pm to 8pm go shopping #low";
		Command command = new Command(userInput);
		Command actualCommand = dispatcher.parseCommand(command);
		
		String[] expectedPara = addParser.determineParameters
				(userInput);
		
		Command expectedCommand = new Command(userInput, 
				COMMAND_TYPE.ADD, "on mon 5pm to 8pm go shopping #low", expectedPara);
		
		
		assertEquals(expectedCommand.getOriginal(), actualCommand.getOriginal());
		assertEquals(expectedCommand.getType(), actualCommand.getType());
		assertEquals(expectedCommand.getContent(), actualCommand.getContent());
		assertArrayEquals(expectedCommand.getParameters(), actualCommand.getParameters());
	}
	
	@Test
	//cover a case with the command keyword
	public void test1() throws InvalidInputFormatException {
		String userInput = "add on mon 5pm to 8pm go shopping #low";
		Command command = new Command(userInput);
		Command actualCommand = dispatcher.parseCommand(command);
		
		String[] expectedPara = addParser.determineParameters
				("on mon 5pm to 8pm go shopping #low");
		
		Command expectedCommand = new Command(userInput, 
				COMMAND_TYPE.ADD, "on mon 5pm to 8pm go shopping #low", expectedPara);
		
		
		assertEquals(expectedCommand.getOriginal(), actualCommand.getOriginal());
		assertEquals(expectedCommand.getType(), actualCommand.getType());
		assertEquals(expectedCommand.getContent(), actualCommand.getContent());
		assertArrayEquals(expectedCommand.getParameters(), actualCommand.getParameters());
	}
	
	

}
```
###### java\logic\TestCommandDispatcher.java
``` java

```
###### java\parser\AddCommandParser.java
``` java
package main.java.parser;
import main.java.data.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.PriorityQueue;

import org.apache.commons.lang3.StringUtils;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

public class AddCommandParser extends Parser {

	private static final String WHITE_SPACE = " ";
	private static final String DEADLINE_FLAG_BY = "by";
	private static final String DEADLINE_FLAG_BEFORE = "before";
	private static final String EVENT_FLAG_ON = "on";
	private static final String EVENT_FLAG_AT = "at";
	private static final String RECURRING_FLAG_EVERY = "every";
	private static final String DURATION_FLAG_FROM = "from";
	private static final String DURATION_FLAG_TO = "to";
	private static final String DEADLINE_TASK = "deadline";
	private static final String EVENT_TASK = "one-time event";
	private static final String DURATION_TASK = "duration";
	private static final String PRIORITY_FLAG = "#";	
	private static final String EMPTY_TIME = "[]";
	private static final String EXTRA_WHITE_SPACES = "\\s+";
	private static final String DEFAULT_TIME = "8am";
	private static final String TOMORROW_IN_FULL = "tomorrow";
	private static final String TOMORROW_IN_SHORT = "tmr";
	private static final String OVERDUE_TASK = "overdue";
	private static final String UPCOMING_TASK = "upcoming";
	private static final String FLOATING_TASK = "floating";
	private static final int FIELD_NOT_EXIST = -1;
	private static final String PRIORITY_HIGH_ALIAS = "h";
	private static final String PRIORITY_MEDIUM_ALIAS_1 = "med";
	private static final String PRIORITY_MEDIUM_ALIAS_2 = "m";
	private static final String PRIORITY_LOW_ALIAS = "l";



	protected PrettyTimeParser timeParser;

	public AddCommandParser() {
		super();
		timeParser = new PrettyTimeParser();

	}


	public static void main(String[] args)
	{
		PrettyTimeParser pars = new PrettyTimeParser();
		AddCommandParser parser = new AddCommandParser();
		//System.out.println(parser.isToday(pars.parse("last fri to next mon")));
		//System.out.println(new Date().toString());
		System.out.print(parser.formatToStandardCommandContent("this tmr"));
		//AddCommandParser parser = new AddCommandParser();
	}

	private boolean isToday(List<Date> dates) {
		int size = dates.size();
		if (size == 0) {
			return false;
		}
		else {
			Date today = new Date();
			String todayDate = today.toString().substring(0, 9);
			if (size == 1) {
				if (dates.get(0).toString().substring(0,9).equals(todayDate)) {
					return true;
				}
			}
			else if (size == 2) {
				if (today.after(dates.get(0)) || today.before(dates.get(1))) {
					return true;
				}
			}
		}
		return false;
	}



	public String[] determineParameters(String commandContent) 
			throws InvalidInputFormatException {
		assert commandContent != null;


		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException("Cannot add an empty task!");
		}
		String[] parameters = new String[5];
		commandContent = formatToStandardCommandContent(commandContent);
		parameters[TASK] = determineTask(commandContent);
		if (parameters[TASK].isEmpty()) {
			throw new InvalidInputFormatException("Task name is missing!");
		}
		String timeSegment = determineTimeSegment(commandContent.toLowerCase());
		parameters[TIME] = determineTime(timeSegment);
		parameters[PRIORITY] = determinePriority(commandContent);
		parameters[TASK_TYPE] = determineTaskType(commandContent);
		parameters[STATUS] = determineStatus(timeSegment);

		return parameters;
	}

	protected String determineTask(String content) {
		int timeIndex = getStartingIndexOfIdentifier(content);
		if (timeIndex == FIELD_NOT_EXIST) {
			int priorityIndex = getStartingIndexOfPriority(content);
			if (priorityIndex == FIELD_NOT_EXIST) {
				return content;
			}
			else {
				if (priorityIndex == 0) {
					return EMPTY_STRING;
				}
				return content.substring(0, priorityIndex - 1);
			}
		}
		else {
			if (timeIndex == 0) {
				return EMPTY_STRING;
			}
			return content.substring(0, timeIndex - 1);
		}
	}

	protected String determineTime(String timeSegment) throws InvalidInputFormatException {


		//String timeSegment = determineTimeSegment(content);

		List<Date> dates = timeParser.parse(timeSegment);

		if (dates.size() == 0) {
			return "[]";
		}
		else {
			isTimeAmbiguous(dates, timeSegment);


			//modifyDateToTomorrowIfExpired(dates);
			String result = dates.toString();
			if (!timeSegment.contains("now")) {
				result = setDefaultTimeIfNotSpecified(timeSegment, dates);
			}

			return result;
		}
	}

	private void isTimeAmbiguous(List<Date> dates, String timeSegment) throws InvalidInputFormatException {
		int size = dates.size();
		if (size > 2) {
			throw new InvalidInputFormatException("Ambiguous time entered!");
		}
		if (size == 2) {
			if (!containsWholeWord(timeSegment, DURATION_FLAG_TO)) {
				throw new InvalidInputFormatException("Date format not supported!");
			}
		}
	}

//	private void modifyDateToTomorrowIfExpired(List<Date> dates) {
//
//		for (int i = 0; i < dates.size(); i++) {
//			if (isOverdue(dates.get(i))) {
//				Calendar calendar = Calendar.getInstance();
//				calendar.setTime(dates.get(i));
//				calendar.add(Calendar.DATE, 1);  // number of days to add
//				dates.set(i,calendar.getTime()); // dt is now the new date
//			}
//		}
//
//	}

	private String setDefaultTimeIfNotSpecified(String timeSegment, List<Date> dates) {
		String parsedTime = dates.toString();
		String currentSystemTime = new Date().toString();
		parsedTime = getRoughTime(parsedTime);
		currentSystemTime = getRoughTime(currentSystemTime);

		if (parsedTime.equals(currentSystemTime)) {
			String result = timeParser.parse(
					timeSegment + WHITE_SPACE + DEFAULT_TIME).toString();
			return result;
		}
		else {
			return dates.toString();
		}
	}

	private String getRoughTime(String fullDate) {

		return fullDate.substring(fullDate.indexOf(TIME_SEPARATOR) - 2, 
				fullDate.indexOf(TIME_SEPARATOR, fullDate.indexOf(TIME_SEPARATOR) + 1) + 2);
	}


	private String determineTimeSegment(String content) {
		int timeIndex = getStartingIndexOfIdentifier(content);
		int priorityIndex = getStartingIndexOfPriority(content);
		if (timeIndex == FIELD_NOT_EXIST) {
			return EMPTY_STRING;
		}

		else if (priorityIndex == FIELD_NOT_EXIST) {
			return content.substring(timeIndex);
		}
		else {
			return content.substring(timeIndex, priorityIndex - 1);
		}
	}

	protected String determinePriority(String content) throws InvalidInputFormatException {

		if (content.contains(PRIORITY_FLAG)) {
			String priority = content.substring(content.indexOf(PRIORITY_FLAG) + 1).trim();
			priority = priority.toLowerCase();
			if (!isValidPriority(priority)) {
				throw new InvalidInputFormatException("Please enter a valid priority level");
			}

			return getPriorityInFull(priority);
		}
		else {
			return PRIORITY_LEVEL.NOT_SPECIFIED.getType();
		}
	}

	private boolean isValidPriority(String priority) {

		if (priority.equals(PRIORITY_LEVEL.HIGH.getType()) ||
				priority.equals(PRIORITY_LEVEL.MEDIUM.getType()) ||
				priority.equals(PRIORITY_LEVEL.LOW.getType()) || 
				priority.equals(PRIORITY_HIGH_ALIAS) ||
				priority.equals(PRIORITY_MEDIUM_ALIAS_1) || 
				priority.equals(PRIORITY_MEDIUM_ALIAS_2) || 
				priority.equals(PRIORITY_LOW_ALIAS)) {
			return true;
		}
		return false;
	}

	private String getPriorityInFull(String priority) {
		if (priority.equals(PRIORITY_LEVEL.HIGH.getType()) || 
				priority.equals(PRIORITY_HIGH_ALIAS)) {
			priority = PRIORITY_LEVEL.HIGH.getType();
		}
		else if (priority.equals(PRIORITY_LEVEL.MEDIUM.getType()) || 
				priority.equals(PRIORITY_MEDIUM_ALIAS_1) || 
				priority.equals(PRIORITY_MEDIUM_ALIAS_2)) {
			priority = PRIORITY_LEVEL.MEDIUM.getType();
		}
		else if (priority.equals(PRIORITY_LEVEL.LOW.getType()) ||
				priority.equals(PRIORITY_LOW_ALIAS)) {
			priority = PRIORITY_LEVEL.LOW.getType();
		}
		return priority;
	}

	protected String determineTaskType(String content) {
		int timeIndex = getStartingIndexOfIdentifier(content);
		String timeSegment = determineTimeSegment(content).toLowerCase();
		if (timeIndex == FIELD_NOT_EXIST) {
			return EVENT_TASK;
		}
		else if (isDurationTask(timeSegment)) {
			return DURATION_TASK;
		}
		else {
			if (content.substring(timeIndex, timeIndex + 2).equalsIgnoreCase
					(DEADLINE_FLAG_BY)|| content.substring(timeIndex, 
							timeIndex + 6).equalsIgnoreCase(DEADLINE_FLAG_BEFORE)) {
				return DEADLINE_TASK;
			}

			return EVENT_TASK;
		}
	}
	
	private boolean containsWholeWord(String content, String keyword) {
		String[] segments = content.split(WHITE_SPACE);  
		for (int i = 0; i < segments.length; i++) {
			if (segments[i].equalsIgnoreCase(keyword)) {
				return true;
			}
		}
		return false;
	}
	private boolean isDurationTask(String timeSegment) {
		if (timeParser.parse(timeSegment).size() == 2 &&
				(containsWholeWord(timeSegment, DURATION_FLAG_FROM)
						|| containsWholeWord(timeSegment, DURATION_FLAG_TO))) {
			return true;
		}
		return false;
	}

	protected String determineStatus(String timeSegment) {
		List<Date> dates = timeParser.parse(timeSegment);
		int size = dates.size();
		if (size == 0) {
			return FLOATING_TASK;
		}
		else if (isOverdue(dates.get(size - 1)) && (!dates.toString().
				substring(1,11).equals(new Date().toString().substring(0, 10)))) {
			return OVERDUE_TASK;
		}
		else {
			return UPCOMING_TASK;
		}
	}

	private String addPrepositionIfApplicable(String content) {
		//contains keyword "tomorrow"
		if (content.contains(TOMORROW_IN_FULL)) {
			
			//"tomorrow" is the first word
			if (content.indexOf(TOMORROW_IN_FULL) == 0) {
				int startIndex = content.indexOf(WHITE_SPACE) + 1;
				String nextWord = content.substring(startIndex);
				if (nextWord.indexOf(WHITE_SPACE) != -1) {
					nextWord = nextWord.substring(0, nextWord.indexOf(WHITE_SPACE));
				}
				//there is a valid preposition following "tomorrow"
				if (startIndex < content.length() && 
						isValidTimeIdentifier(nextWord)) {

					content = content.substring(startIndex);
					if (timeParser.parse(content).size() == 0) {
						
						return EVENT_FLAG_ON + WHITE_SPACE + 
								TOMORROW_IN_FULL + WHITE_SPACE + content;
					}
					int index = content.indexOf(WHITE_SPACE) + 1;
					content = content.substring(0, index) + TOMORROW_IN_FULL 
							+ WHITE_SPACE + content.substring(index);
					return content;
				}
				//no preposition after "tomorrow"
				else {

					content = EVENT_FLAG_ON + WHITE_SPACE + content;
				}
			}
			//"tomorrow" is not the first word
			else {
				//determine the position of "tomorrow"
				String[] segments = content.split(WHITE_SPACE);
				int len = segments.length;
				int index = 0;
				for (int i = 0; i < len; i++) {
					if (segments[i].equals(TOMORROW_IN_FULL)) {
						index = i;
						break;
					}
				}

				//there is a valid preposition before "tomorrow"
				if (isValidTimeIdentifier(segments[index - 1])) {
					return content;
				}

				//there is no valid preposition before "tomorrow"
				else {
					if (index + 1 == len) {
						String newContent = EMPTY_STRING;
						for (int i = 0; i < index; i++) {
							newContent += segments[i] + WHITE_SPACE;
						}
						newContent += EVENT_FLAG_ON + WHITE_SPACE + segments[index];
						return newContent;
					}
					if (index + 1 < len && 
							!isValidTimeIdentifier(segments[index + 1])) {
						String newContent = EMPTY_STRING;
						for (int i = 0; i < index; i++) {
							newContent += segments[i] + WHITE_SPACE;
						}
						newContent += EVENT_FLAG_ON + WHITE_SPACE + segments[index];
						for (int i = index + 1; i < len; i++) {
							newContent += WHITE_SPACE + segments[i];
						}
						return newContent;
					}

					if (index + 1 < len && 
							isValidTimeIdentifier(segments[index + 1])) {
						String newContent = EMPTY_STRING;
						for (int i = 0; i < index; i++) {
							newContent += segments[i] + WHITE_SPACE;
						}
						String rest = EMPTY_STRING;
						for (int i = index + 2; i < len; i++) {
							rest += WHITE_SPACE + segments[i];
						}
						if (timeParser.parse(rest).size() == 0) {
							newContent += EVENT_FLAG_ON + WHITE_SPACE + segments[index];
						}
						else {
							newContent += segments[index + 1] + 
									WHITE_SPACE + segments[index];
						}

						return newContent + rest;
					}
				}
			}
		}
		return content;
	}

	protected String formatToStandardCommandContent(String content) {
		content = content.replaceAll(EXTRA_WHITE_SPACES, WHITE_SPACE).trim();
		content = StringUtils.replace(content, TOMORROW_IN_SHORT, TOMORROW_IN_FULL);
		if (isNecessaryToAddPrepostion(content)) {
			content = addPrepositionIfApplicable(content);
		}
		//System.out.println(content);
		int time = getStartingIndexOfIdentifier(content);
		int priority = getStartingIndexOfPriority(content);
		int task = getStartingIndexOfTask(content, time, priority);

		//task only
		if (time == FIELD_NOT_EXIST && priority == FIELD_NOT_EXIST) {
			return content;
		}
		//no time,has priority
		else if (time == FIELD_NOT_EXIST) {
			//only priority
			if (task == FIELD_NOT_EXIST) {
				return content;
			}

			else {
				if (task > priority) {
					return content.substring(task)+ WHITE_SPACE + 
							content.substring(0, task - 1);
				}
				else {
					return content;
				}
			}
		}
		//no priority,has time
		else if (priority == FIELD_NOT_EXIST) {
			//only time
			if (task == FIELD_NOT_EXIST) {
				return content;
			}

			else {
				if (task > time) {
					return content.substring(task)+ WHITE_SPACE + 
							content.substring(0, task - 1);
				}
				else {
					return content;
				}
			}	
		}

		//time,priority,task(maybe)
		else {
			if (task == FIELD_NOT_EXIST) {
				if (time > priority) {
					return content.substring(time)+ WHITE_SPACE + 
							content.substring(0, time - 1);
				}
				else {
					return content;
				}
			}

			else {
				if (task < time && task < priority) {
					if (time < priority) {
						return content;
					}
					//task-priority-time
					else {
						return content.substring(task,priority) + 
								content.substring(time) + WHITE_SPACE + 
								content.substring(priority,time - 1);
					}
				}
				//priority-task-time
				else if (task < time) {
					return content.substring(task) + WHITE_SPACE +
							content.substring(priority,task - 1);
				}
				//time-task-priority
				else if (task < priority) {
					return content.substring(task, priority - 1) + WHITE_SPACE 
							+ content.substring(time, task - 1) + WHITE_SPACE +
							content.substring(priority);
				}
				//task is the last
				else {
					//time-priority-task
					if (time < priority) {
						return content.substring(task) + WHITE_SPACE 
								+ content.substring(time, priority - 1) + WHITE_SPACE +
								content.substring(priority, task - 1);
					}
					//priority-time-task
					else {
						return content.substring(task) + WHITE_SPACE 
								+ content.substring(time, task - 1) + WHITE_SPACE +
								content.substring(priority, time - 1);
					}
				}
			}
		}
	}


	private boolean isNecessaryToAddPrepostion(String content) {
		int index = content.indexOf(TOMORROW_IN_FULL);
		if (index == -1) {
			return false;
		}
		String front = content.substring(0,index).trim();
		if (timeParser.parse(front).toString().equals(EMPTY_TIME)) {
			return true;
		}
		return false;
	}


	private int getStartingIndexOfPriority(String content) {
		return content.indexOf(PRIORITY_FLAG);
	}


	private int getStartingIndexOfTask(String content, int timeIndex, int priorityIndex) {
		//no time, no tag -> must have and only task
		if (timeIndex == FIELD_NOT_EXIST && priorityIndex == FIELD_NOT_EXIST) {
			return 0;
		}
		//no time, has tag -> tag-task/task-tag/tag
		else if (timeIndex == FIELD_NOT_EXIST) {
			//tag
			if (!content.contains(WHITE_SPACE)) {
				return FIELD_NOT_EXIST;
			}
			else {
				//tag-task
				if (content.substring(0,1).equals(PRIORITY_FLAG)) {
					return content.indexOf(WHITE_SPACE) + 1;
				}
				//task-tag
				else {
					return 0;
				}
			}
		}

		//no priority, has time -> time-task/task-time/time
		else if (priorityIndex == FIELD_NOT_EXIST) {

			//<time>/<time-task>
			if (timeIndex == 0) {
				//fill in
				return locateTaskIndexInSegment(content);	
			}
			//task-time
			else {
				return 0;
			}	
		}

		//has time, has priority -> 
		//1.task-priority-time
		//2.task-time-priority
		//3.time-task-priority
		//4.priority-task-time
		//5.time-priority-task
		//6.priority-time-task
		//7.priority-time
		//8.time-priority
		else {
			//3,5,8
			if (timeIndex == 0) {
				//5
				if (priorityIndex < content.lastIndexOf(WHITE_SPACE)) {
					return content.indexOf(WHITE_SPACE,content.indexOf
							(PRIORITY_FLAG)) + 1;
				}
				//3,8   <time-task>-priority/<time>-priority
				else {
					//fill in
					String segment = content.substring(0,content.indexOf
							(PRIORITY_FLAG) - 1);
					return locateTaskIndexInSegment(segment);


				}	
			}

			//4,6,7
			else if (priorityIndex == 0) {
				//6,7 priority-<time>/priority-<time-task>
				if (timeIndex == content.indexOf(WHITE_SPACE) + 1) {
					//fill in
					int baseIndex = content.indexOf(WHITE_SPACE) + 1;
					String segment = content.substring(baseIndex);
					int index = locateTaskIndexInSegment(segment);
					if (index == FIELD_NOT_EXIST) {
						return FIELD_NOT_EXIST;
					}
					return baseIndex + index;

				}
				//4
				else {
					return content.indexOf(WHITE_SPACE) + 1;
				}

			}

			//1,2 ->task must be present
			else {
				return 0;
			}

		}
	}

	private int locateTaskIndexInSegment(String content) {
		int taskIndex = FIELD_NOT_EXIST;
		//input: time/time-task
		int count = StringUtils.countMatches(content, WHITE_SPACE);


		if (count == 1) {
			return FIELD_NOT_EXIST;
		}

		else {
			String oldDate = getRoughDate(timeParser.parse(content).toString());
			for (int i = 2; i <= count; i++) {
				int index = StringUtils.ordinalIndexOf(content, WHITE_SPACE, i);
				String newDate = content.substring(0, index);
				newDate = timeParser.parse(newDate).toString();
				if (!newDate.equals(EMPTY_TIME)) {
					newDate = getRoughDate(newDate);
				}
				if (newDate.equals(oldDate)) {
					taskIndex = index + 1;
					break;
				}
			}
			return taskIndex;
		}

	}



	private int getStartingIndexOfIdentifier(String content) {
		String[] segments = content.split(WHITE_SPACE);
		int numSpace = segments.length - 1;

		//no time
		if (numSpace == 0) {
			return FIELD_NOT_EXIST;
		}

		PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
		int pointer = 0;


		for (int i = 1; i <= numSpace; i++) {
			int index = StringUtils.ordinalIndexOf(content, WHITE_SPACE, i);


			if (isValidTimeIdentifier(content.substring(pointer, index))) {
				pq.offer(pointer);
			}

			pointer = index + 1;
		}

		ArrayList<Integer> list = new ArrayList<Integer>();

		int size = pq.size();

		for (int i = 0; i < size; i++) {
			list.add(pq.poll());
		}



		//no time
		if (list.size() == 0) {
			return FIELD_NOT_EXIST;
		}

		//the only one match is the real identifier
		if (list.size() == 1) {
			if (!timeParser.parse(content).toString().equals(EMPTY_TIME)) {
				return list.get(0);
			}
			else {
				return FIELD_NOT_EXIST;
			}
		}

		if (list.size() == 2) {
			if (!timeParser.parse(content.substring(list.get(0), list.get(1)))
					.toString().equals(EMPTY_TIME)) {
				return list.get(0);
			}

			else if (!timeParser.parse(content.substring(list.get(1)))
					.toString().equals(EMPTY_TIME)) {
				return list.get(1);
			}

			else {
				return FIELD_NOT_EXIST;
			}
		}

		//list size is at least 3
		//check substrings to determine the starting index of the real identifier
		for (int i = 0; i < list.size(); i++) {
			if (i < list.size() - 1) {
				String substring = content.substring(list.get(i),list.get(i + 1));
				if (!timeParser.parse(substring).toString().equals(EMPTY_TIME)) {
					return list.get(i);
				}
			}

			else {
				String substring = content.substring(list.get(i));
				if (!timeParser.parse(substring).toString().equals(EMPTY_TIME)) {
					return list.get(i);
				}
			}
		}


		return FIELD_NOT_EXIST;
	}

	private boolean isValidTimeIdentifier(String content) {
		String word = content.toLowerCase();
		//content.spit
		if (word.equals(DEADLINE_FLAG_BY)) {
			return true;
		}
		else if (word.equals(DEADLINE_FLAG_BEFORE)) {
			return true;
		}

		else if (word.equals(EVENT_FLAG_AT)) {
			return true;
		}
		else if (word.equals(EVENT_FLAG_ON)) {
			return true;
		}
		else if (word.equals(RECURRING_FLAG_EVERY)) {
			return true;
		}
		else if (word.equals(DURATION_FLAG_FROM)) {
			return true;
		}
		return false;
	}

	private boolean isOverdue(Date time) {
		return time.before(new Date());
	}

	private String getRoughDate(String time) {
		String[] segments = time.split(TIME_SEPARATOR);
		time = segments[0] + segments[1] + segments[2].substring(2);
		return time;
	}
}
```
###### java\parser\AddCommandParser.java
``` java

```
###### java\parser\DeleteCommandParser.java
``` java
package main.java.parser;

import main.java.data.COMMAND_TYPE;

public class DeleteCommandParser extends Parser {

	public DeleteCommandParser() {
		super();
	}

	public String[] determineParameters(String commandContent) throws InvalidInputFormatException {
		//assert commandType != null;
		//assert 1==2;
		String[] parameters = new String[5];
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException("Cannot delete nothing!");
		}
		else {
			parameters[TASK] = commandContent;

		}
		return parameters;
	}

}
```
###### java\parser\DeleteCommandParser.java
``` java

```
###### java\parser\EditCommandParser.java
``` java
package main.java.parser;

import java.util.ArrayList;

import main.java.data.Task;
import main.java.data.TransientTask;
import main.java.data.Command;

public class EditCommandParser extends AddCommandParser {

	private static final String EDIT_COMMAND_SEPARATOR = ",";
	private static final String EDIT_TASK_SEPARATOR = " , ";

	public EditCommandParser() {
		super();
	}

	public String[] determineParameters(String commandContent)throws InvalidInputFormatException {
		assert commandContent != null;
		//assert 1==2;
		checkAndHandleInvalidCommand(commandContent);
		String[] segments = commandContent.split(EDIT_COMMAND_SEPARATOR);
		String[] parameters = new String[5];
		parameters[TASK] = determineTaskForEditCommand(segments);
		parameters[TIME] = determineTimeForEditCommand(segments);
		parameters[PRIORITY] = determinePriorityForEditCommand(segments);
		parameters[TASK_TYPE] = determineTaskTypeForEditCommand(segments);
		parameters[STATUS] = determineStatusForEditCommand(segments);
		return parameters;
	}

	private void checkAndHandleInvalidCommand(String commandContent) throws InvalidInputFormatException {
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException("Cannot edit nothing!");
		}
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) == -1) {
			throw new InvalidInputFormatException("Invalid format for edit command!");
		}
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) == 0) {
			throw new InvalidInputFormatException("Please specify the task to edit!");
		}
		else if (commandContent.indexOf(EDIT_COMMAND_SEPARATOR) == commandContent.length() - 1) {
			throw new InvalidInputFormatException("Please specify the information to be updated!");
		}
	}

	private String determineTaskForEditCommand(String[] segments) {

		String task_A = determineTask(formatToStandardCommandContent(segments[0].trim())); 
		String task_B = determineTask(formatToStandardCommandContent(segments[1].trim()));

		if (task_B.equals(EMPTY_STRING)) {
			return task_A + EDIT_TASK_SEPARATOR + task_A;
		}

		else {
			return task_A + EDIT_TASK_SEPARATOR + task_B;
		}
	}

	private String determineTimeForEditCommand(String[] segments) throws InvalidInputFormatException {

		String time_A = determineTime(formatToStandardCommandContent(segments[0].trim())); 
		String time_B = determineTime(formatToStandardCommandContent(segments[1].trim()));

		return time_A + EDIT_TASK_SEPARATOR + time_B;

	}

	private String determinePriorityForEditCommand(String[] segments) throws InvalidInputFormatException {
		//assert content != null;
		String priority_A = determinePriority(formatToStandardCommandContent(segments[0].trim())); 
		String priority_B = determinePriority(formatToStandardCommandContent(segments[1].trim()));

		return priority_A + EDIT_TASK_SEPARATOR + priority_B;
	}


	private String determineTaskTypeForEditCommand(String[] segments) {
		String taskType;
		taskType = determineTaskType(formatToStandardCommandContent
				(segments[0].trim())) + EDIT_TASK_SEPARATOR +
				determineTaskType(formatToStandardCommandContent
						(segments[1].trim()));
		return taskType;
	}

	private String determineStatusForEditCommand(String[] segments) {
		String status;
		status = determineStatus(formatToStandardCommandContent(segments[0].trim())) +
				EDIT_TASK_SEPARATOR + determineStatus(
						formatToStandardCommandContent(segments[1].trim()));
		return status;
	}



	public static ArrayList<Task> parseEditTask(TransientTask task) {
		Task task_A;
		Task task_B;
		String toDo_A, toDo_B;
		String time_A, time_B;
		String priority_A, priority_B;
		String type_A, type_B;
		String status_A, status_B;
		
		toDo_A = task.getTask().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		toDo_B = task.getTask().split(EDIT_COMMAND_SEPARATOR)[1].trim();
		
		String time = task.getTime().replaceAll(" , ", "%");
		time_A = time.split("%")[0].trim();
		time_B = time.split("%")[1].trim();

		priority_A = task.getPriority().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		priority_B = task.getPriority().split(EDIT_COMMAND_SEPARATOR)[1].trim();
		
		type_A = task.getType().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		type_B = task.getType().split(EDIT_COMMAND_SEPARATOR)[1].trim();

		status_A = task.getStatus().split(EDIT_COMMAND_SEPARATOR)[0].trim();
		status_B = task.getStatus().split(EDIT_COMMAND_SEPARATOR)[1].trim();

		task_A = new Task(toDo_A, Command.getTime(time_A), Command.getPriority(priority_A), 
				Command.getType(type_A), Command.getStatus(status_A));
	
		task_B = new Task(toDo_B, Command.getTime(time_B), Command.getPriority(priority_B), 
				Command.getType(type_B), Command.getStatus(status_B));


		ArrayList<Task> result = new ArrayList<Task>();
		result.add(task_A);
		result.add(task_B);
		return result;
	}

}
```
###### java\parser\EditCommandParser.java
``` java

```
###### java\parser\InvalidInputFormatException.java
``` java
package main.java.parser;

public class InvalidInputFormatException extends Exception {
	public InvalidInputFormatException(String message) {
		super(message);
	}
}
```
###### java\parser\InvalidInputFormatException.java
``` java

```
###### java\parser\Parser.java
``` java
package main.java.parser;
import main.java.data.*;
public abstract class Parser {
	
	protected static final String TIME_SEPARATOR = ":";
	protected static final String EMPTY_STRING = "";
	
	protected static final int TASK = 0;
	protected static final int TIME = 1;
	protected static final int PRIORITY = 2;
	protected static final int TASK_TYPE = 3;
	protected static final int STATUS = 4;
		
	public Parser() {
		
	}
	
	
	public String[] determineParameters(COMMAND_TYPE commandType, String commandContent) 
			throws InvalidInputFormatException {
		assert commandType != null;
		assert commandContent != null;
		
		if (commandType != COMMAND_TYPE.CLEAR_COMPLETE && 
				commandType != COMMAND_TYPE.CLEAR_UPCOMING && 
				commandType != COMMAND_TYPE.UNDO &&
				commandType != COMMAND_TYPE.REDO) {
			if (commandContent.isEmpty()) {
				throw new InvalidInputFormatException("This command requires parameter!");
			}
		}
		String[] parameters = new String[5];
		if (!commandContent.isEmpty()) {
			parameters[TASK] = commandContent;
		}

		return parameters;
	}

}

```
###### java\parser\Parser.java
``` java

```
###### java\parser\SearchCommandParser.java
``` java
package main.java.parser;

public class SearchCommandParser extends Parser {
	public SearchCommandParser() {
		super();
	}

}
```
###### java\parser\SearchCommandParser.java
``` java

```
###### java\parser\ShowCommandParser.java
``` java
package main.java.parser;

import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import main.java.data.PRIORITY_LEVEL;

public class ShowCommandParser extends Parser {

	public ShowCommandParser() {
		super();
	}

	public String[] determineParameters(String commandContent) throws InvalidInputFormatException {
		//assert commandType != null;
		//assert 1==2;
		String[] parameters = new String[5];
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException("Cannot show nothing!");
		}
		
		else {
			setShowFiterIfApplicable(parameters, commandContent);
		}
		
		return parameters;
	}

	private void setShowFiterIfApplicable(String[] parameters, String commandContent) throws InvalidInputFormatException {
		//System.out.println("haha");
		commandContent = commandContent.toLowerCase();
		commandContent = commandContent.replaceAll("tmr", "tomorrow");
		PrettyTimeParser timeParser = new PrettyTimeParser();
		List<Date> dates = timeParser.parse(commandContent);
		
		if (dates.size() == 1) {
			parameters[TIME] = dates.toString();
		}
		else if (commandContent.equals("h") || commandContent.equals("high")) {
			parameters[PRIORITY] = PRIORITY_LEVEL.HIGH.getType();
			
		}
		else if (commandContent.equals("med") || commandContent.equals("m") 
				|| commandContent.equals("medium")) {
			parameters[PRIORITY] = PRIORITY_LEVEL.MEDIUM.getType();
		}
		else if (commandContent.equals("low") || commandContent.equals("l")) {
			parameters[PRIORITY] = PRIORITY_LEVEL.LOW.getType();
		}
		else {
			throw new InvalidInputFormatException("Please choose a valid filter!");
		}
		
	}

}
```
###### java\parser\ShowCommandParser.java
``` java

```
###### java\parser\SortCommandParser.java
``` java
package main.java.parser;

import main.java.data.COMMAND_TYPE;

public class SortCommandParser extends Parser {

	public SortCommandParser() {
		super();
	}

	public String[] determineParameters(String commandContent) throws InvalidInputFormatException {
		//assert commandType != null;
		//assert 1==2;
		String[] parameters = new String[5];
		if (commandContent.isEmpty()) {
			throw new InvalidInputFormatException("Cannot sort by nothing!");
		}
		else {
			String parameter = commandContent.toLowerCase();
			if (parameter.equals("time") || parameter.equals("name") ||
					parameter.equals("priority")) {
				parameters[TASK] = commandContent;
			}
			else {
				throw new InvalidInputFormatException("Sort by \"name\", \"time\" or \"priority\" only!");
			}
		}
		return parameters;
	}

}
```
###### java\parser\SortCommandParser.java
``` java

```
###### java\parser\StorageCommandParser.java
``` java
package main.java.parser;

public class StorageCommandParser extends Parser {

	public StorageCommandParser() {
		super();
	}
	
}
```
###### java\parser\StorageCommandParser.java
``` java

```
###### java\parser\TestParser.java
``` java
package main.java.parser;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

public class TestParser {
	private static AddCommandParser addParser;
	private static EditCommandParser editParser;
	private static PrettyTimeParser parser;
	private static final int TASK = 0;
	private static final int TIME = 1;
	private static final int PRIORITY = 2;
	private static final int TASK_TYPE = 3;



	@Before
	public void setUp() throws Exception {
		parser = new PrettyTimeParser();
		addParser = new AddCommandParser();
		editParser = new EditCommandParser();
	}
	
	@Test
	public void testFormatting() throws InvalidInputFormatException {
		String testInput = "#medium on tmr I can play basketball with my father";
		
		String expected = "I can play basketball with my father on tomorrow #medium";
		String actual = addParser.formatToStandardCommandContent(testInput);
		
		assertEquals(actual, expected);
	}

	@Test
	//cover a normal case with correct input
	public void testAddWithFullParameters() throws InvalidInputFormatException {
		
		String testInput = "play soccer with my friend on sunday #high";
		
		String[] parametersActual = addParser.determineParameters(testInput);
		
		String[] parametersExpected = new String[4];
		parametersExpected[TASK] = "play soccer with my friend";
		String time = parser.parse("on sunday 8am").toString();
		parametersExpected[TIME] = time.substring(1,time.length() - 1);
		parametersExpected[PRIORITY] = "high";
		parametersExpected[TASK_TYPE] = "one-time event";
		
		assertArrayEquals(parametersActual, parametersExpected);

	}
	
	
	
	
	@Test
	//cover a exception case with incorrect input
	public void testAdd2() {
		String testInput = "";
		String expectedErrorMsg = "Cannot add an empty task!";
		try {
			String[] parameters = addParser.determineParameters(testInput);
		} catch (InvalidInputFormatException e) {
			// TODO Auto-generated catch block
			String actualErrorMsg = e.getMessage();
			assertEquals(actualErrorMsg, expectedErrorMsg);
		}
		
	}

	@Test
	public void testEdit() throws InvalidInputFormatException {
		
		String testInput = "better to get, play soccer with my friend on sunday #high";
		
		String[] parametersActual = editParser.determineParameters(testInput);
		
		String[] parametersExpected = new String[4];
		parametersExpected[TASK] = "better to get , play soccer with my friend";
		String time = parser.parse(" , on sunday 8am").toString();
		parametersExpected[TIME] = " , " + time.substring(1,time.length() - 1);
		parametersExpected[PRIORITY] = " , high";
		parametersExpected[TASK_TYPE] = " , one-time event";
		
		assertArrayEquals(parametersActual, parametersExpected);

	}
	



}
```
###### java\parser\TestParser.java
``` java

```
